"""
Comment key because I leave myelf lots of notes haha:
TD:     Functionality that needs to be fleshed out
QQ:     A question that needs to be asked about a line of code
DEBUG:  A line of code, usually a print statement, using for debuging & to be deleted after the issue is resolved
TEST:   A line or block of code that is not part of the final program and purely for test/debugging
FIX(?): A line of code that might be causing problems or needs to be fixed
##:     Indicates that line was built for CS 361
"""

import sys, csv, time, cv2

from onr_introduction_screen import *

from PyQt5 import QtGui
from PyQt5.QtCore import QThread, Qt, QObject, pyqtSignal, QTimer
from PyQt5.QtGui import QColor, QFont
from PyQt5.QtWidgets import (
    QMainWindow, QVBoxLayout, QHBoxLayout,
    QWidget, QGridLayout, QPushButton, QLabel, QRadioButton
)

# constants
NUM_SENSORS = 18
MIN_FORCE = 0.0

LOW_THRESHHOLD = 0.20

# global color list - hex values are hard coded and generated by ChatGPT at https://chat.openai.com/
COLOR_LIST = [ # white (small force values) to black (large force values)
    '#FFFFFF', '#F8F8F8', '#F1F1F1', '#EAEAEA', '#E3E3E3',
    '#DCDCDC', '#D5D5D5', '#CECECE', '#C7C7C7', '#C0C0C0',
    '#B9B9B9', '#B2B2B2', '#ABABAB', '#A4A4A4', '#9D9D9D',
    '#969696', '#8F8F8F', '#888888', '#818181', '#7A7A7A',
    '#737373', '#6C6C6C', '#656565', '#5E5E5E', '#575757',
    '#505050', '#494949', '#424242', '#3B3B3B', '#343434',
    '#2D2D2D', '#262626', '#1F1F1F', '#181818', '#111111',
    '#0A0A0A', '#030303', '#000000', '#030303', '#0A0A0A',
    '#111111', '#181818', '#1F1F1F', '#262626', '#2D2D2D',
    '#343434', '#3B3B3B', '#424242', '#494949', '#505050',
    '#575757', '#5E5E5E', '#656565', '#6C6C6C', '#737373',
    '#7A7A7A', '#818181', '#888888', '#8F8F8F', '#969696',
    '#9D9D9D', '#A4A4A4', '#ABABAB', '#B2B2B2', '#B9B9B9',
    '#C0C0C0', '#C7C7C7', '#CECECE', '#D5D5D5', '#DCDCDC',
    '#E3E3E3', '#EAEAEA', '#F1F1F1', '#F8F8F8', '#FFFFFF'
]



"""
This is the window that pops up in between each video, rating user confidence
"""
class ConfidenceWindow(QMainWindow):

    def __init__(self):
        super().__init__()

        self.stopClicked = False

        # window stuff
        self.setWindowTitle("Confidence")
        self.setFixedHeight(400)
        self.setFixedWidth(1050)
        self.setWindowModality(QtCore.Qt.ApplicationModal) # makes IdWindow a modal, meaning it freezes interaction with the window that calls it until it is closed

        # layouts
        outerLayout = QVBoxLayout()
        radioLayout = QVBoxLayout()

        # text
        self.question = QLabel()
        if self.stopClicked == True:
            self.question.setText("How confident are you that the grasp attempt would have failed?")
        else:
            self.question.setText("How confident are you that the grasp attempt was successful?")
        self.question.setFont(QFont('Arial', 18))
        outerLayout.addWidget(self.question, alignment=Qt.AlignCenter | Qt.AlignTop)

        # radio buttons
        
        self.radiobutton1 = QRadioButton("Very Confident")
        self.radiobutton1.setFont(QFont('Arial', 15))
        radioLayout.addWidget(self.radiobutton1)

        self.radiobutton2 = QRadioButton("Somewhat Confident")
        self.radiobutton2.setFont(QFont('Arial', 15))
        radioLayout.addWidget(self.radiobutton2)

        self.radiobutton3 = QRadioButton("Neither Confident Nor Unconfident")
        self.radiobutton3.setFont(QFont('Arial', 15))
        radioLayout.addWidget(self.radiobutton3)

        self.radiobutton4 = QRadioButton("Somewhat Unconfident")
        self.radiobutton4.setFont(QFont('Arial', 15))
        radioLayout.addWidget(self.radiobutton4)

        self.radiobutton5 = QRadioButton("Very Unconfident")
        self.radiobutton5.setFont(QFont('Arial', 15))
        radioLayout.addWidget(self.radiobutton5)

        # continue button
        self.continueButton = QPushButton("Continue")
        self.continueButton.setFixedSize(200, 50)
        self.continueButton.setFont(QFont('Arial', 15))
        self.continueButton.setEnabled(False)

        # pull it all together
        outerLayout.addWidget(self.question)
        outerLayout.addLayout(radioLayout)
        outerLayout.addWidget(self.continueButton, alignment=Qt.AlignRight)

        centralWidget = QWidget(self)
        centralWidget.setLayout(outerLayout)
        self.setCentralWidget(centralWidget)


    def setStopClicked(self, stop):
        self.stopClicked = stop
        if self.stopClicked == True:
            self.question.setText("How confident are you that the grasp attempt would have failed?")
        else:
            self.question.setText("How confident are you that the grasp attempt was successful?")


    def getStopClicked(self):
        return self.stopClicked



class CountdownBox(QMessageBox):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("")
        self.setText("3")
        self.setFixedHeight(200)
        self.setFixedWidth(200)
        self.setWindowModality(QtCore.Qt.ApplicationModal)

        # Create a timer
        self.timer = QTimer()
        self.timer.setInterval(1000)  # Timer interval in milliseconds
        self.timer.timeout.connect(self.update_time)
        self.time_remaining = 3  # Initial time remaining

        # Start the timer
        self.timer.start()

    def update_time(self):
        # Update the time remaining
        self.time_remaining -= 1
        if self.time_remaining == 0:
            # Stop the timer when countdown finishes
            self.timer.stop()
            self.accept()
        else:
            # Update the text with the remaining time
            self.setText(str(self.time_remaining))
    


"""
Custom signal class, used for communication between the worker thread and the main thread to update the GUI
"""
class SignalEmitter(QObject):
    sensorSignal = pyqtSignal()
    frameSignal = pyqtSignal(QtGui.QPixmap)
    finishedSignal = pyqtSignal()
    


"""
This class creates a new thread for the continuous update display to work in - it updates the sensors
It is triggered when the user clicks play, and ends when the video ends or the user clicks stop
"""
class WorkerThread(QThread):

    def __init__(self, controller):
        super().__init__()
        self.controller = controller
        self.dataLeft = len(self.controller.forcesMatrix)


    def _calculateSkipRate(self):
        diff = self.dataLeft - self.framesLeft
        return round(self.dataLeft/diff)


    def run(self):
        # read in video
        self.video = cv2.VideoCapture(self.controller.videoFile)
        if not self.video.isOpened():
            print("Error opening video")
        else:
            print("Video opened sucessfully")

        self.frameCount = self.video.get(cv2.CAP_PROP_FRAME_COUNT)
        self.framesLeft = self.frameCount
        print("Frame count: " + str(self.frameCount))

        # update
        videoStatus,frame = self.video.read() # reads in video. videoStatus is a bool, frame is the current video frame
        while (not self.isInterruptionRequested() and videoStatus): # while user didn't click stop
            self.controller.emitter.sensorSignal.emit() # updates sensor display
            self.controller.emitter.frameSignal.emit(QtGui.QPixmap.fromImage(QtGui.QImage(frame.data, frame.shape[1], frame.shape[0], QtGui.QImage.Format_BGR888)).scaled(750, 900, Qt.KeepAspectRatio)) # updates frame
            videoStatus,frame = self.video.read()
            time.sleep(.003) # Every 20 miliseconds

        if not videoStatus:
            self.controller.emitter.finishedSignal.emit()



"""
This class represents a single sensor, and the force value associated with it
""" 
class Sensor():
    def __init__(self):
        self._force = 0  # force of an individual sensor
        self.maxForce = 0


    # setter for force
    def setForce(self, newForce):
        self._force = newForce


    def setMaxForce(self, force):
        self.maxForce = force


    # returns the hex value associated with a sensor's force
    def getColor(self):
        binWidth = (self.maxForce - MIN_FORCE) / len(COLOR_LIST) # range / number of bins
        idx = int(self._force / binWidth)
        return COLOR_LIST[idx]



"""
This class respresents the model. It contains a list of 18 Sensor objects
"""
class SensorArray(): # SensoryArray is the class, sensorList is the python list of Sensor objects
    def __init__(self):
        # creates list of Sensor objects
        self.sensorList = []
        for i in range(NUM_SENSORS):
            mySensor = Sensor()
            self.sensorList.append(mySensor)
    

    # updates the force value associated with each Sensor object in sensorList
    def updateSensorForces(self, forcesList):
        for i in range(NUM_SENSORS):
            self.sensorList[i].setForce(forcesList[i])


    # getter for sensorList
    def getSensors(self):
        return self.sensorList   


    def setMaxForce(self, force):
        # print("Set new max force in sensorArray: " + str(force))
        for sensor in self.sensorList:
            sensor.setMaxForce(force)

    

"""
This class represents the main window
It contains all the layouts and widgets of the main window, as well as functions to update the display
"""
class InterfaceWindow(QMainWindow): # inherits from QMainWindow

    # constructor
    def __init__(self):
        super().__init__()
        
        # window stuff
        self.setWindowTitle("Tactile View")
        self.setFixedHeight(950)
        self.setFixedWidth(1900)

        # create layouts
        outerLayout = QHBoxLayout() # overall layout
        leftLayout = QVBoxLayout() # contains video and buttons
        rightLayout = QVBoxLayout() # contains tactile grids
        gridLayout = QHBoxLayout() # contains both grids
        buttonsLayout = QHBoxLayout()
        leftLabelGrid = QGridLayout() # grid of labels that make up the gripper
        rightLabelGrid = QGridLayout()

        # creates 18 color labels and add them to colorLabelList
        self.colorLabelList = []
        for i in range(NUM_SENSORS):
            label = QLabel(self)
            # label.setStyleSheet("border: 1px solid black;")
            label.setAutoFillBackground(True)
            self.palette = label.palette()
            self.palette.setColor(label.backgroundRole(), QColor("white")) # sets initial color to white
            label.setPalette(self.palette)
            self.colorLabelList.append(label)
        
        # add color labels to grids in the following order
        """
        1  2  3    10  11  12
        4  5  6    13  14  15
        7  8  9    16  17  18
        """
        for i in range(3):
            for j in range (3):
                leftLabelGrid.addWidget(self.colorLabelList[i * 3 + j], i , j) # adds first 8 in a 3x3 grid
        
        for i in range(3):
            for j in range (3):
                rightLabelGrid.addWidget(self.colorLabelList[9 + i * 3 + j], i , j) # adds last 8 in a 3x3 grid     

        # video stuff
        self.imageFrame = QLabel()

        self.stopButton = QPushButton("STOP")
        self.stopButton.setFixedSize(200, 50)
        self.stopButton.setFont(QFont('Arial', 15))

        self.nextButton = QPushButton("Next")
        self.nextButton.setFixedSize(200, 50)
        self.nextButton.setFont(QFont('Arial', 15))
        self.nextButton.setVisible(False)

        # gripper image
        self.legend = QLabel()
        self.legend.setPixmap(QtGui.QPixmap("instruction_images\\legend_bar.png").scaled(200, 8500, Qt.KeepAspectRatio))

        buttonsLayout.addWidget(self.stopButton, alignment=Qt.AlignLeft)
        buttonsLayout.addSpacing(20)
        buttonsLayout.addWidget(self.nextButton)
        buttonsLayout.setContentsMargins(150, 10, 150, 10)
        leftLayout.addWidget(self.imageFrame, alignment=Qt.AlignCenter)
        leftLayout.addLayout(buttonsLayout)
        gridLayout.addLayout(leftLabelGrid)
        gridLayout.addSpacing(20)
        gridLayout.addLayout(rightLabelGrid)
        gridLayout.setContentsMargins(5, 100, 5, 100)
        rightLayout.addLayout(gridLayout)
        outerLayout.addLayout(leftLayout)
        outerLayout.addLayout(rightLayout)
        # outerLayout.addWidget(self.legend)

        # pull it all together
        centralWidget = QWidget(self)
        centralWidget.setLayout(outerLayout)
        self.setCentralWidget(centralWidget)



"""
This class is the controller class
Most of the functionality is done here
"""
class InterfaceController:     

    def __init__(self, view, model, csvFile, videoFile, vidId, testNum):
        self.sensorArray = model #sensorArray is a class
        self.view = view
        self.forcesMatrix = [] # a 2d list of all the force values in a csv
        self.currentRow = 0 # represents the current row of the forceMatrix being dispalyed
        self.videoFile = videoFile
        self.csvFile = csvFile
        self.vidId = vidId
        self.testNum = testNum
        self.view.setWindowTitle("Tactile View - " + str(self.testNum))

        self.stopClicked = False
        self.participant_id = ""
        
        # custom signal
        self.emitter = SignalEmitter()

        # timing
        self.startTime = 0
        self.endTime = 0
        
        # click listeners
        self.view.stopButton.clicked.connect(self._stopMedia)
        self.view.nextButton.clicked.connect(self._nextClicked)
        self.emitter.sensorSignal.connect(self.sensorUpdateSlot)
        self.emitter.frameSignal.connect(self.frameUpdateSlot)
        self.emitter.finishedSignal.connect(self.videoFinished)

        self._readForces()

        # threads
        self.myWorkerThread = WorkerThread(self)

        # pop up
        self.popUp = ConfidenceWindow()
        self.popUp.radiobutton1.toggled.connect(self._radioSelected)
        self.popUp.radiobutton2.toggled.connect(self._radioSelected)
        self.popUp.radiobutton3.toggled.connect(self._radioSelected)
        self.popUp.radiobutton4.toggled.connect(self._radioSelected)
        self.popUp.radiobutton5.toggled.connect(self._radioSelected)
        self.popUp.continueButton.clicked.connect(self._continueClicked)

        # wait, then play
        # countdownWindow = CountdownBox()
        # countdownWindow.exec_()
        self._playMedia()


    # The code in this function is partially generated by ChatGPT at https://chat.openai.com/
    def _readForces(self):
        maxList = []
        with open(self.csvFile, mode ='r') as file:
            csvReader = csv.reader(file)
            next(csvReader) # skips the first (header) row
            for line in csvReader:
                lineValues = [] # a list of each force on a line of the csv file
                for value in line[1:]: # skips the first (timestamp) column
                    if float(value) > LOW_THRESHHOLD:
                        lineValues.append(float(value))
                    else:
                        lineValues.append(0.0)
                self.forcesMatrix.append(lineValues)
                maxList.append(max(lineValues))
        print("Max: " + str(max(maxList)))
        self.sensorArray.setMaxForce(max(maxList) + .001)
                

    # this function serves as the slot for the sensorSignal and calls updateSensors
    def sensorUpdateSlot(self):
        self._updateSensors()


    # this function serves as the slot for the frameSignal and updates the video display
    def frameUpdateSlot(self, pixmap):
        self.view.imageFrame.setPixmap(pixmap)


    # This function updates each sensor object accoring to force values from the current row in ForcesMatrix
    # each time it's called, it moves to the next row of ForcesMatrix
    def _updateSensors(self):
        if self.currentRow < len(self.forcesMatrix): # only updates as long as there exists more data
            self.sensorArray.updateSensorForces(self.forcesMatrix[self.currentRow])
            for i in range(NUM_SENSORS):
                # updates forces
                newForce = self.forcesMatrix[self.currentRow][i]

                # updates colors
                sensorList = self.sensorArray.getSensors()
                palette = self.view.colorLabelList[i].palette()
                palette.setColor(self.view.colorLabelList[i].backgroundRole(), QColor(sensorList[i].getColor()))
                self.view.colorLabelList[i].setPalette(palette)
            self.currentRow += 1 # increments the row of ForcesMatrix


    def _playMedia(self):
        self.myWorkerThread.start()
        self.startTime = time.time()


    def _stopMedia(self):
        # stops worker threads
        self.myWorkerThread.requestInterruption()
        self.stopClicked = True
        self.popUp.setStopClicked(True)
        self.videoFinished()
    

    # this function is called each time the video stops (whether the user clicks stop or the video ends)
    def videoFinished(self):
        self.endTime = time.time()
        timeElaped = self.endTime - self.startTime # records the time elapsed between start and stop in seconds.

        ## reads current participant id
        with open("participant_data\\participant_id.txt", "r") as file:
            self.participant_id = file.read()

        ## writes information in file named after participant id
        with open("participant_data\\" + str(self.participant_id) + ".csv", "a") as file:
            file.write(str(self.testNum) + ",")
            file.write(str(self.vidId) + ",")
            file.write(str(self.stopClicked) + ",")
            file.write(str(round(timeElaped, 2)) + ",")

        self._nextClicked()


    def _nextClicked(self):
        print("Next button clicked")

        # bring up confidence page
        self.popUp.show()

    
    def _radioSelected(self):
        print("radio button selected")

        self.sender = self.popUp.sender()

        self.popUp.continueButton.setEnabled(True)

    
    def _continueClicked(self):

        with open("participant_data\\" + str(self.participant_id) + ".csv", "a") as file:
            file.write(self.sender.text())
            file.write("\n")
        self.popUp.close()
        self.view.close()
            



# """
# The main class. It creates all objects and starts the program
# """
# def main():

#     # creates window
#     tactileInterface = QApplication([])
#     tiWindow = InterfaceWindow()
#     tiWindow.show()

#     # creates model
#     mySensorArray = SensorArray()

#     # creates controller
#     tiController = InterfaceController(tiWindow, mySensorArray, VIDEO_FILE, CSV_FILE, 16)

#     sys.exit(tactileInterface.exec())

# if __name__ == "__main__":
#     main()